# shopping-cart 


# Функции, определяемые пользователем 

## Пример синтаксиса, используемого для описания функций:

```php

// Псевдокод для демонстрации использования функций
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Пример функции.\n";
    return $retval;
}
?>
```

Внутри функции можно использовать любой корректный PHP-код, в том числе другие функции.

Имена функций следуют тем же правилам, что и другие метки в PHP. Корректное имя функции начинается с буквы или знака подчеркивания, за которым следует любое количество букв, цифр или знаков подчеркивания. В качестве регулярного выражения оно может быть выражено так: 

```php

    [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*.
```

Функции не обязаны быть определены до их использования, исключая тот случай, когда функции определяются условно.

В случае, когда функция определяется в зависимости от какого-либо условия, обработка описания функции должна предшествовать ее вызову.

## Функции, зависящие от условий

```php

<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она еще не определена, но мы можем 
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar() 
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
```

## Вложенные функции

```php

<?php
function foo() 
{
  function bar() 
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она еще не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала ее доступной. */

bar();

?>
```

Все функции PHP имеют глобальную область видимости - они могут быть вызваны вне функции, даже если были определены внутри и наоборот.

PHP не поддерживает перегрузку функции, также отсутствует возможность переопределить или удалить объявленную ранее функцию.

Имена функций регистронезависимы, тем не менее, более предпочтительно вызывать функции так, как они были объявлены. 

Функции PHP поддерживают как списки аргументов переменной длины, так и значения аргументов по умолчанию. 


## Рекурсивные функции

Можно вызывать функции PHP рекурсивно.

```php

<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
```
   
Рекурсивный вызов методов/процедур с глубиной более 100-200 уровней рекурсии может вызвать переполнение стека и привести к аварийному завершению скрипта. В частности, бесконечная рекурсия будет считаться программной ошибкой. 


## Получить URI текущей страницы

```php

function getURI(){
    return $_SERVER['REQUEST_URI'];
}

//получаем строку запроса

$uri = getURI();

```

## Функция array()

Массив может быть создан языковой конструкцией array(). В качестве параметров она принимает любое количество разделенных запятыми пар key => value (ключ => значение).

```php

<?php

$routes = array(
    '/contact' => 'ContactController',
    '/about' => 'AboutController',
    //Главаня страница
    '/' => 'HomeController',  
);

```

число элементов в массиве не обязательно знать заранее — его можно вычислить при помощи функции count():

```php

<?php
  for ($i = 1; $i <= count($routes); $i++)
  {
    echo $routes[$i]." ";
  }
?>
```

# Циклы while 

Циклы while являются простейшим видом циклов в PHP. Они ведут себя так же, как и их коллеги из языка C. Простейшей формой цикла while является следующее выражение:

```php

    while (expr)
        statement
```

Смысл выражения while очень прост. Оно указывает PHP выполнять вложенные выражения повторно до тех пор, пока выражение в самом while является TRUE. Значение выражения expr проверяется каждый раз перед началом цикла, поэтому даже если значение выражения изменится в процессе выполнения вложенных выражений в цикле, выполнение не прекратится до конца итерации (каждый раз, когда PHP выполняет выражения в цикле - это одна итерация). В том случае, если выражение while равно FALSE с самого начала, вложенные выражения ни разу не будут выполнены.

Также, как и с оператором if, вы можете группировать несколько выражений внутри одного цикла while, заключая эти выражения между фигурными скобками или используя альтернативный синтаксис:

```php

    while (expr):
        statement
        ...
    endwhile;

```

Следующие примеры идентичны, и оба выведут числа от 1 до 10:

```php

    <?php
    /* пример 1 */

    $i = 1;
    while ($i <= 10) {
        echo $i++;  /* выводится будет значение переменной
                       $i перед её увеличением
                       (post-increment) */
    }

    /* пример 2 */

    $i = 1;
    while ($i <= 10):
        echo $i;
        $i++;
    endwhile;
    ?>
```

# Цикл do-while 

Цикл do-while очень похож на цикл while, с тем отличием, что истинность выражения проверяется в конце итерации, а не в начале. Главное отличие от обычного цикла while в том, что первая итерация цикла do-while гарантированно выполнится (истинность выражения проверяется в конце итерации), тогда как она может не выполниться в обычном цикле while (истинность выражения которого проверяется в начале выполнения каждой итерации, и если изначально имеет значение FALSE, то выполнение цикла будет прервано сразу).

Есть только один вариант синтаксиса цикла do-while:

```php

    <?php
    $i = 0;
    do {
        echo $i;
    } while ($i > 0);
    ?>

```

В примере цикл будет выполнен ровно один раз, так как после первой итерации, когда проверяется истинность выражения, она будет вычислена как FALSE ($i не больше 0) и выполнение цикла прекратится.


# Цикл for

Цикл for самый сложный цикл в PHP. Он ведет себя так же как его аналог в языке C. Синтаксис цикла for следующий:

```php

    for (expr1; expr2; expr3)
        statement
```

Первое выражение (expr1) всегда вычисляется (выполняется) только один раз в начале цикла.

В начале каждой итерации оценивается выражение expr2. Если оно принимает значение TRUE, то цикл продолжается, и вложенные операторы будут выполнены. Если оно принимает значение FALSE, выполнение цикла заканчивается.

В конце каждой итерации выражение expr3 вычисляется (выполняется ).

Каждое из выражений может быть пустым или содержать несколько выражений, разделенных запятыми. В expr2 все выражения, разделенные запятыми, вычисляются, но результат берется из последнего. Если выражение expr2 отсутствует, это означает, что цикл будет выполняться бесконечно. (PHP неявно воспринимает это значение как TRUE, так же, как в языке C). Это может быть не столь бесполезно, сколь вы могли подумать, так как часто необходимо прервать цикл, используя условный оператор break вместо использования выражения в цикле for, которое принимает истинное значение.

Рассмотрим следующие примеры. Все из них отображают числа от 1 до 10:

```php

    <?php
    /* пример 1 */

    for ($i = 1; $i <= 10; $i++) {
        echo $i;
    }

    /* пример 2 */

    for ($i = 1; ; $i++) {
        if ($i > 10) {
            break;
        }
        echo $i;
    }

    /* пример 3 */

    $i = 1;
    for (; ; ) {
        if ($i > 10) {
            break;
        }
        echo $i;
        $i++;
    }

    /* пример 4 */

    for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);
    ?>
```

PHP также поддерживает альтернативный синтаксис с двоеточием для циклов for.

```php

    for (expr1; expr2; expr3):
        statement
        ...
    endfor;
```

## Перебор массивов.

```php

    <?php
    /*
     * Это массив с некоторыми данными, которые мы хотим изменить
     * при работе цикла.
     */
    $people = array(
        array('name' => 'Kalle', 'salt' => 856412),
        array('name' => 'Pierre', 'salt' => 215863)
    );

    for($i = 0; $i < count($people); ++$i) {
        $people[$i]['salt'] = mt_rand(000000, 999999);
    }
    ?>
```

# Конструкция foreach 

Конструкция foreach предоставляет простой способ перебора массивов. Foreach работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными. Существует два вида синтаксиса:

```php

    foreach (array_expression as $value)
        statement

    foreach (array_expression as $key => $value)
        statement
```

Первый цикл перебирает массив, задаваемый с помощью array_expression. На каждой итерации значение текущего элемента присваивается переменной $value и внутренний указатель массива увеличивается на единицу (таким образом, на следующей итерации цикла работа будет происходить со следующим элементом).

Второй цикл будет дополнительно соотносить ключ текущего элемента с переменной $key на каждой итерации.

```php

    foreach ($arr as $value) {
        echo "Значение: $value<br />\n";
    }

    foreach ($arr as $key => $value) {
        echo "Ключ: $key; Значение: $value<br />\n";
    }

```


```php

    // Проверить наличие такого запроса в routes

    foreach ($routes as $uriPattern => $path) {

     //Сравниваем uriPattern и $uri
     if($uriPattern == $uri){

       // Определить контроллер
       $controllerName = $path;

       //Подключаем файл контроллера
       $controllerFile = CONTROLLERS . $controllerName . EXT;

       include_once($controllerFile);

       $result = true;

       if($result !== null)
         break;
        }
    }
```

# isset

Определяет, была ли установлена переменная значением отличным от NULL

Если переменная была удалена с помощью unset(), то она больше не считается установленной. isset() вернет FALSE, если проверяемая переменная имеет значение NULL. Следует помнить, что null-байт ("\0") не является эквивалентом константе PHP NULL.

Если были переданы несколько параметров, то isset() вернет TRUE только в том случае, если все параметры определены. Проверка происходит слева направо и заканчивается, как только будет встречена неопределенная переменная.

Возвращает TRUE, если var определена и ее значение отлично от NULL, и FALSE в противном случае.

Проверка нечислового индекса строки возвращает FALSE.


## Пример использования isset()

```php

$var = '';

    // Проверка вернет TRUE, поэтому текст будет напечатан.
    if (isset($var)) {
        echo "Эта переменная определена, поэтому меня и напечатали.";
    }
```


# empty — Проверяет, пуста ли переменная

```php

    bool empty ( mixed $var )

```

Проверяет, считается ли переменная пустой. Переменная считается пустой, если она не существует или её значение равно FALSE. empty() не генерирует предупреждение, если переменная не существует.

Возвращает FALSE, если var существует и содержит непустое ненулевое значение. В противном случае возвращает TRUE.

Следующие значения воспринимаются как пустые:

```php

    "" (пустая строка)
    0 (целое число)
    0.0 (дробное число)
    "0" (строка)
    NULL
    FALSE
    array() (пустой массив)
    $var; (переменная объявлена, но не имеет значения)

```


```php

    function getURI(){
        if (isset($_SERVER['REQUEST_URI']) and !empty($_SERVER['REQUEST_URI']))
            return $_SERVER['REQUEST_URI'];
    }

```

## Получить URL текущей страницы

```php

    function getUrl() {
      $url  = ( $_SERVER["HTTPS"] != 'on' ) ? 'http://'.$_SERVER["SERVER_NAME"] :  'https://'.$_SERVER["SERVER_NAME"];
      $url .= ( $_SERVER["SERVER_PORT"] != 80 ) ? ":".$_SERVER["SERVER_PORT"] : "";
      $url .= $_SERVER["REQUEST_URI"];
      return $url;
    }    

```
Пример использования

```php

    echo getUrl(); // вернет url вида http://xx.yy/404.html

```


# trim

trim — Удаляет пробелы (или другие символы) из начала и конца строки

```php

string trim ( string $str [, string $character_mask = " \t\n\r\0\x0B" ] )

```

Эта функция возвращает строку str с удаленными из начала и конца строки пробелами. Если второй параметр не передан, trim() удаляет следующие символы:

```php

    " " (ASCII 32 (0x20)), обычный пробел.
    "\t" (ASCII 9 (0x09)), символ табуляции.
    "\n" (ASCII 10 (0x0A)), символ перевода строки.
    "\r" (ASCII 13 (0x0D)), символ возврата каретки.
    "\0" (ASCII 0 (0x00)), NUL-байт.
    "\x0B" (ASCII 11 (0x0B)), вертикальная табуляция.
```

Список параметров

str - Обрезаемая строка (string).
character_mask - Можно также задать список символов для удаления с помощью необязательного аргумента character_mask. Просто перечислите все символы, которые вы хотите удалить. Можно указать конструкцию .. для обозначения диапазона символов.


```php

    function getURI(){
        if (isset($_SERVER['REQUEST_URI']) and !empty($_SERVER['REQUEST_URI']))
            return trim($_SERVER['REQUEST_URI'], '/');
    }

```


```php

    $routes = array(
        'contact' => 'ContactController',
        'about' => 'AboutController',
        //Главаня страница
        '' => 'HomeController',  
    );

```


# file_exists

file_exists — Проверяет наличие указанного файла или каталога

```php
    bool file_exists ( string $filename )

```
filename - Путь к файлу или каталогу.

Возвращает TRUE, если файл или каталог, указанный параметром filename, существует, иначе возвращает FALSE.

Данная функция возвращает FALSE для символических ссылок, указывающих на несуществующие файлы.

Если файлы недоступны из-за ограничений, налагаемых безопасным режимом, то данная функция вернет FALSE. Однако, эти файлы все еще могут быть подключены, если они располагаются в каталоге safe_mode_include_dir.


## Проверка существования файла

```php

  foreach ($routes as $uriPattern => $path) {

     //Сравниваем uriPattern и $uri
     if($uriPattern == $uri){

       // Определить контроллер
       $controllerName = $path;

       //Подключаем файл контроллера
       $controllerFile = CONTROLLERS . $controllerName . EXT;

       if(file_exists($controllerFile)){
         include_once($controllerFile);
         $result = true;
         }

       if($result !== null)
         break;
        }
    }
```

## Something gone wrong!

```php

    if($result === null){
         require_once VIEWS.'404'.EXT;
    }
```


```html

    <div class="feature_header text-center">
          <h3 class="feature_title">OOPS! <b>404</b></h3>
          <h4 class="feature_sub">Something gone wrong! </h4>
          <div class="divider"></div>
    </div>
```


## Разыменование массива


```php

    <?php

    return [
        'contact' => 'ContactController',
        'about' => 'AboutController',
        //Главаня страница
        'index.php' => 'HomeController', 
        '' => 'HomeController',  
    ];

```

```php

    $filename = CONFIG.'routes'.EXT;

    if (file_exists($filename)) {
        $routes = include($filename);
    } else {
        echo "Файл $filename не существует";
    }

```

# Вставка и удаление элементов массивов

## Функция array_push

```
array_push(alist &$Arr, mixed $var1 [, mixed $var2, …])

```
Эта функция добавляет к списку $Arr элементы $var1, $var2 и т. д. Она присваивает им числовые индексы — точно так же, как это происходит для стандарных []. Если вам нужно добавить всего один элемент, наверное, проще и будет воспользоваться этим оператором:

```php

array_push($Arr,1000); // вызываем функцию…
$Arr[]=100; // то же самое, но короче

```
функция array_push() воспринимает массив, как стек, и добавляет элементы всегда в его конец. Она возвращает новое число элементов в массиве.


## Функция array_pop()

Функция array_pop(), является противоположностью array_push(), снимает элемент с "вершины" стека (то есть берет последний элемент списка) и возвращает его, удалив после этого его из $Arr. С помощью этой функции мы можем строить конструкции, напоминающие стек. Если список $Arr был пуст, функция возвращает пустую строку.

## Функция array_unshift()
```
array_unshift(list &$Arr, mixed $var1 [, mixed $var2, …])
```
Функция array_unshift очень похожа на array_push(), но добавляет перечисленные элементы не в конец, а в начало массива. При этом порядок следования $var1, $var2 и т. д. остается тем же, т. е. элементы как бы "вдвигаются" в список слева. Новым элементам списка, как обычно, назначаются числовые индексы, начиная с 0; при этом все ключи старых элементов массива, которые также были числовыми, изменяются (чаще всего они увеличиваются на число вставляемых значений). Функция возвращает новый размер массива. 

## Функция array_shift

```
mixed array_shift(list &$Arr)
```

Функция array_shift извлекает первый элемент массива $Arr и возвращает его. Она сильно напоминает array_pop(), но только получает начальный, а не конечный элемент, а также производит довольно сильную "встряску" всего массива: ведь при извлечении первого элемента приходится корректировать все числовые индексы у всех оставшихся элементов…
