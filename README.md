# shopping-cart 


# Guestbook


```html
      
      <ul class="nav navbar-nav navbar-right ">
        <li class="active"> <a href="/" >Home</a></li>
        <li><a href="#" id="megacatalog">Catalog</a> </li>
        <li><a href="/about" >About Us </a> </li>
        <li><a href="#blog" >Blog</a> </li>

        <li><a href="/guestbook" >Guestbook</a> </li>

        <li><a href="/contact" >Contact Us</a> </li>
        <li id="cart-trigger"><a href="#" ><i class="fa fa-shopping-cart shopping-cart"></i></a></li>
                        
      </ul>

```

# Routes

```php

<?php
return [
    'contact' => 'ContactController',
    'about' => 'AboutController',
    'blog' => 'BlogController',
    'guestbook' => 'GuestbookController',
    //Главаня страница
    'index.php' => 'HomeController', 
    '' => 'HomeController',  
];

?>
```
# Controller

```php

  <?php

  require_once VIEWS.'guestbook/index.php';

```
# View

```html

        <div class="col-md-10">
                        <div class="content-box-large">
                            <div class="panel-heading">
                                <div class="panel-title">Enter your guestbook comments here:</div>
                              
                                <div class="panel-options">
                                  <a href="#" data-rel="collapse"><i class="glyphicon glyphicon-refresh"></i></a>
                                  <a href="#" data-rel="reload"><i class="glyphicon glyphicon-cog"></i></a>
                                </div>
                            </div>
                            <div class="panel-body">
                                <form class="form-horizontal" role="form" method="POST" action="">
                                  <div class="form-group">
                                    <label for="username" class="col-sm-2 control-label">Your Name</label>
                                    <div class="col-sm-10">
                                      <input type="text" class="form-control" id="username" placeholder="Your Name" name="username">
                                    </div>
                                  </div>
                                  <div class="form-group">
                                    <label for="email" class="col-sm-2 control-label">Your Email</label>
                                    <div class="col-sm-10">
                                      <input type="email" class="form-control" id="email" placeholder="Your Email" name="email">
                                    </div>
                                  </div>
                                  <div class="form-group">
                                    <label class="col-sm-2 control-label">Your Comment</label>
                                    <div class="col-sm-10">
                                      <textarea class="form-control" placeholder="Your Comment" rows="3" name="comment"></textarea>
                                    </div>
                                  </div>
                                  
                                  
                                  <div class="form-group">
                                    <div class="col-sm-offset-2 col-sm-10">
                                      <button type="submit" class="btn btn-primary">Add Comment</button>
                                    </div>
                                  </div>
                                </form>
                            </div>
                        </div>
            </div>
            
            <div class="clearfix"></div>
                 Past comments.... 

```


# Открытие и закрытие файлов

Для открытия файлов в PHP определена функция fopen(). 

```
resource fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] )
```
fopen() закрепляет именованный ресурс, указанный в аргументе filename, за потоком.


## filename
Если filename передан в форме "scheme://...", он считается URL'ом и PHP проведёт поиск обработчика протокола (также известного как "обертка") для этой схемы. Если ни одна обёртка не закреплена за протоколом, PHP выдаст замечание, чтобы помочь вам отследить потенциальную проблему в вашем скрипте и затем продолжит выполнение, как если бы filename указывал на обыкновенный файл.

Если установлено, что filename указывает на локальный файл, тогда выполняется попытка открыть поток к этому файлу. Файл должен быть доступен PHP, так что вам следует убедиться, что права доступа на файл это разрешают. 

## mode
Параметр mode указывает тип доступа, который вы запрашиваете у потока. Он может быть одним из следующих вариантов:

- 'r' Открывает файл только для чтения; помещает указатель в начало файла.
- 'r+'  Открывает файл для чтения и записи; помещает указатель в начало файла.
- 'w' Открывает файл только для записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пробует его создать.
- 'w+'  Открывает файл для чтения и записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пытается его создать.
- 'a' Открывает файл только для записи; помещает указатель в конец файла. Если файл не существует - пытается его создать. В данном режиме функция fseek() не применима, записи всегда добавляются.
- 'a+'  Открывает файл для чтения и записи; помещает указатель в конец файла. Если файл не существует - пытается его создать. В данном режиме функция fseek() влияет только на позицию чтения, записи всегда добавляются.
- 'x' Создаёт и открывает только для записи; помещает указатель в начало файла. Если файл уже существует, вызов fopen() закончится неудачей, вернёт FALSE и выдаст ошибку уровня E_WARNING. Если файл не существует, попытается его создать. Это эквивалентно указанию флагов O_EXCL|O_CREAT для внутреннего системного вызова open(2).
- 'x+'  Создаёт и открывает для чтения и записи; в остальном имеет то же поведение что и'x'.
- 'c' Открывает файл только для записи. Если файл не существует, то он создается. Если же файл существует, то он не обрезается (в отличие от 'w'), и вызов к этой функции не вызывает ошибку (также как и в случае с 'x'). Указатель на файл будет установлен на начало файла. Это может быть полезно при желании заблокировать файл (см. flock()) перед изменением, так как использование 'w' может обрезать файл еще до того как была получена блокировка (если вы желаете обрезать файл, можно использовать функцию ftruncate() после запроса на блокировку).
- 'c+'  Открывает файл для чтения и записи; в остальном имеет то же поведение, что и 'c'.
- 'e' Установить флаг close-on-exec (закрыть при запуске) на открытый файловый дескриптор. Доступно только в PHP скомпилированном на системах поддерживающих POSIX.1-2008.

Разные семейства операционных систем имеют разные соглашения относительно окончания строк. Когда вы пишете текст и хотите вставить разрыв строки, вы должны использовать правильные символы (или символ) для вашей операционной системы. Системы семейства Unix используют \n в качестве символа конца строки, системы семейства Windows используют \r\n в качестве символов окончания строки и системы семейства Macintosh используют \r в качестве символа конца строки.

Если вы используете неверный символ конца строки при редактировании файлов, вы можете обнаружить, что при открытии эти файлы "странно выглядят".

Windows предлагает флаг режима текстовой трансляции ('t'), который автоматически переведёт \n в \r\n во время работы с файлом. И наоборот - вы также можете использовать 'b', чтобы принудительно включить бинарный режим, в котором ваши данные не будут преобразовываться. Чтобы использовать эти режимы, укажите 'b' или 't' последней буквой параметра mode.

Из соображений портируемости, настоятельно рекомендуется всегда использовать флаг 'b' при открытии файлов с помощью fopen().

Кроме того, из соображений портируемости, также настойчиво рекомендуется переписать старый код, который полагается на режим 't', чтобы вместо этого он использовал правильные концы строк и режим 'b'.

## use_include_path
Необязательный третий параметр use_include_path может быть установлен в '1' или TRUE, если вы также хотите провести поиск файла в include_path.

Возвращает указатель на файл в случае успешной работы, или FALSE в случае ошибки.

Если открыть файл не удалось, будет сгенерирована ошибка уровня E_WARNING. Вы можете использовать оператор @ для подавления этой ошибки.

## Пример использования fopen()

```php

<?php
$handle = fopen("/home/rasmus/file.txt", "r");
$handle = fopen("/home/rasmus/file.gif", "wb");
$handle = fopen("http://www.example.com/", "r");
$handle = fopen("ftp://user:password@example.com/somefile.txt", "w");
?>
```

Данная функция также может принимать директории в качестве параметра filename. Если вы не знаете, является ли filename файлом или директорией, то вам может понадобиться использовать функцию is_dir() до вызова функции fopen().

# Оператор управления ошибками 
PHP поддерживает один оператор управления ошибками: знак (@). В случае, если он предшествует какому-либо выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.

Если вы установили собственную функцию обработки ошибок с помощью set_error_handler(), то она все равно будет вызвана, однако, если внутри этой функции будет вызвана функция error_reporting(), то она вернет 0, если функция, вызвавшая данную ошибку, была подавлена с помощью @.

В случае, если установлена опция track_errors , все генерируемые сообщения об ошибках будут сохраняться в переменной $php_errormsg. Эта переменная будет перезаписываться при каждой новой ошибке, поэтому в случае необходимости проверяйте ее сразу же.

```php

<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

?>
```
Оператор @ работает только с выражениями. Есть простое правило: если что-то возвращает значение, значит вы можете использовать перед ним оператор @. Например, вы можете использовать @ перед именем переменной, произвольной функцией или вызовом include, константой и так далее. В то же время вы не можете использовать этот оператор перед определением функции или класса, условными конструкциями, такими как if, foreach и т.д.

На сегодняшний день оператор "@" подавляет вывод сообщений даже о критических ошибках, прерывающих работу скрипта. Помимо всего прочего, это означает, что если вы использовали "@" для подавления ошибок, возникающих при работе какой-либо функции, в случае если она недоступна или написана неправильно, дальнейшая работа скрипта будет остановлена без каких-либо уведомлений.

# feof — Проверяет, достигнут ли конец файла

bool feof ( resource $handle )

## handle
Указатель на файл должен быть корректным и указывать на файл, успешно открытый функциями fopen() или fsockopen() (и все еще не закрытым функцией fclose()).

Возвращает TRUE, если указатель файла указывает на EOF или произошла ошибка (в том числе таймаут сокета), иначе возвращает FALSE.


Если передан неверный файловый указатель, то вы можете получить бесконечный цикл, так как feof() не сможет вернуть TRUE.

## Пример feof() с неверным файловым указателем

```php
<?php
// если файл не может быть прочтен или не существует, fopen вернет FALSE
$file = @fopen("no_such_file", "r");

// FALSE от fopen вызовет предупреждение и следующий цикл станет бесконечным
while (!feof($file)) {
}
fclose($file);
```

# fclose

После окончания работы файл надо закрыть с помощью функции fclose(), которая принимает в качестве параметра дескриптор файла. 

```
bool fclose ( resource $handle )
```
Функция закрывает файл, на который указывает дескриптор handle.

## handle
Дескриптор должен быть корректным и указывать на файл, открытый ранее с помощью функции fopen() или fsockopen().

Возвращает TRUE в случае успешного завершения или FALSE в случае возникновения ошибки.

## Простой пример использования функции fclose()

```php
<?php

$handle = fopen('somefile.txt', 'r') or die("не удалось открыть файл");

fclose($handle);

?>
```
Конструкция or die("текст ошибки") позволяет прекратить работу скрипта и вывесте некоторое сообщение об ошибке, если функция fopen не смогла открыть файл.

# Чтение файла
Для чтения файла можно использовать несколько функций. Для построчного чтения используется функция fgets(), которая получает дескриптор файла и возвращает одну считанную строку. 

```php

<?php
$fd = fopen("form.php", 'r') or die("не удалось открыть файл");
while(!feof($fd))
{
    $str = htmlentities(fgets($fd));
    echo $str;
}
fclose($fd);
?>
```
При каждом вызове fgets() PHP будет помещать указатель в конец считанной строки. Чтобы проследить окончание файла, используется функция feof(), которая возвращает true при завершении файла. И пока не будет достигнут конец файла, мы можем применять функцию fgets().


# Чтение файла полностью
Если нам надо прочитать файл полностью, то мы можем облегчить себе жизнь, применив функцию file_get_contents():

```php
<?php
$str = htmlentities(file_get_contents("form.php"));
echo $str;
?>
```
При этом нам не надо открывать явно файл, получать дескриптор, а затем закрывать файл.

Использование функции file_get_contents() наиболее предпочтительно в случае необходимости получить содержимое файла целиком, поскольку для улучшения производительности функция использует технику отображения файла в память (memory mapping), если она поддерживается вашей операционной системой.

# Поблочное считывание
Также можно провести поблочное считывание, то есть считывать определенное количество байт из файла с помощью функции fread():

```php
<?php
$fd = fopen("form.php", 'r') or die("не удалось открыть файл");
while(!feof($fd))
{
    $str = htmlentities(fread($fd, 600));
    echo $str;
}
fclose($fd);
?>
```
Функция fread() принимает два параметра: дескриптор считываемого файла и количество считываемых байтов. При считывании блока указатель в файле становится в конец этого блока. И также с помощью функции feof() можно отследить завершение файла.

```php
$handle = fopen(DB."comments", "rt");

$comments = '';

while (!feof($handle))
    $comments .= fread($handle, 4096);
fclose($handle);
```

# file

array file ( string $filename [, int $flags = 0 [, resource $context ]] )
Читает содержимое файла и помещает его в массив.

Можно также использовать функцию file_get_contents() для получения файла в виде строки.

## filename
Путь к файлу.

Для этой функции вы можете использовать URL в качестве имени файла, если была включена опция fopen wrappers. 

## flags
В качестве необязательного параметра flags может можно указать одну или более следующих констант:

- FILE_USE_INCLUDE_PATH - Ищет файл в include_path.
- FILE_IGNORE_NEW_LINES - Не добавлять новую строку к концу каждого элемента массива
- FILE_SKIP_EMPTY_LINES - Пропускать пустые строки

Возвращает файл в виде массива. Каждый элемент массива соответствует строке файла, с символами новой строки включительно. В случае ошибки file() возвращает FALSE.

Каждая строка в полученном массиве будет завершаться символами конца строки (если вы не указали флаг FILE_IGNORE_NEW_LINES), поэтому, если вам будет нужно избавиться от этих символов, вы можете использовать функцию rtrim().

Вызывает ошибку уровня E_WARNING, если файл не существует.

# Подсчет количества строк в файле

```php
$file=file("my_file.txt");
$count=count($file);
echo $count;
```

# str_replace
```
mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )
```
Эта функция возвращает строку или массив, в котором все вхождения search в subject заменены на replace.

Если не нужны сложные правила поиска/замены (например, регулярные выражения), использование этой функции предпочтительнее preg_replace().

Если search и replace - массивы, то str_replace() использует каждое значение из соответствующего массива для поиска и замены в subject. Если в массиве replace меньше элементов, чем в search, в качестве строки замены для оставшихся значений будет использована пустая строка. Если search - массив, а replace - строка, то эта строка замены будет использована для каждого элемента массива search. Обратный случай смысла не имеет.

Если search или replace являются массивами, их элементы будут обработаны от первого к последнему.

## search
Искомое значение, также известное как needle (иголка). Для множества искомых значений можно использовать массив.

## replace
Значение замены, будет использовано для замены искомых значений search. Для множества значений можно использовать массив.

## subject
Строка или массив, в котором производится поиск и замена, также известный как haystack (стог сена).

Если subject является массивом, то поиск с заменой будет осуществляться над каждым элементом subject, а результатом функции также будет являться массив.

## count
Если передан, то будет установлен в количество произведенных замен.

Эта функция возвращает строку или массив с замененными значениями.


## Примеры использования str_replace()

```php
<?php
  
  // присваивает <body text='black'>
  $bodytag = str_replace("%body%", "black", "<body text='%body%'>");

  // присваивает: Hll Wrld f PHP
  $vowels = array("a", "e", "i", "o", "u", "A", "E", "I", "O", "U");
  $onlyconsonants = str_replace($vowels, "", "Hello World of PHP");

  // присваивает: You should eat pizza, beer, and ice cream every day
  $phrase  = "You should eat fruits, vegetables, and fiber every day.";
  $healthy = array("fruits", "vegetables", "fiber");
  $yummy   = array("pizza", "beer", "ice cream");

  $newphrase = str_replace($healthy, $yummy, $phrase);

  // присваивает: 2
  $str = str_replace("ll", "", "good golly miss molly!", $count);
  echo $count;
  ?>

```

# htmlspecialchars
```
string htmlspecialchars ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string 
$encoding = ini_get("default_charset") [, bool $double_encode = true ]]] )
```
В HTML некоторые символы имеют особый смысл и должны быть представлены в виде HTML-сущностей, чтобы сохранить их значение. Эта функция возвращает строку, над которой проведены эти преобразования. 

Если входная строка, переданная в эту функцию и результирующий документ используют одинаковую кодировку символов, то этой функции достаточно, чтобы подготовить данные для вставки в большинство частей HTML документа. Однако, если данные содержат символы, не определенные в кодировке символов результирующего документа и вы ожидаете сохранения этих символов (как числовые или именованные сущности), то вам недостаточно будет этой и htmlentities() функций (которые только преобразуют подстроки с соответствующими сущностями). Необходимо использовать функцию mb_encode_numericentity().

Производятся следующие преобразования

```
  
  & (амперсанд) &amp;
  " (двойные кавычки) &quot;, если не установлена ENT_NOQUOTES
  ' (одинарные кавычки) &#039; (для ENT_HTML401) или &apos; (для ENT_XML1, ENT_XHTML или ENT_HTML5), но только если установлена ENT_QUOTES
  < (меньше)  &lt;
  > (больше)  &gt;

```
## string
Конвертируемая строка (string).

## flags
Битовая маска из нижеуказанных флагов, определяющих режим обработки кавычек, некорректных кодовых последовательностей и используемый тип документа. По умолчанию используется ENT_COMPAT | ENT_HTML401.

Доступные значения параметра flags

- ENT_COMPAT  Преобразует двойные кавычки, одинарные кавычки не изменяются.
- ENT_QUOTES  Преобразует как двойные, так и одинарные кавычки.
- ENT_NOQUOTES  Оставляет без изменения как двойные, так и одинарные кавычки.
- ENT_IGNORE  Без всяких уведомительных сообщений отбрасывает некорректные кодовые последовательности вместо возврата пустой строки. Использование этого флага не рекомендуется, так как это может привести к » негативным последствиям, связанным с безопасностью.
- ENT_SUBSTITUTE  Заменяет некорреткные кодовые последовательности символом замены Юникода U+FFFD в случае использования UTF-8.
- ENT_DISALLOWED  Заменяет неверные коды символов для заданного типа документа символом замены юникода U+FFFD (UTF-8)
- ENT_HTML401 Обработка кода в соответствии с HTML 4.01.
- ENT_XML1  Обработка кода в соответствии с XML 1.
- ENT_XHTML Обработка кода в соответствии с XHTML.
- ENT_HTML5 Обработка кода в соответствии с HTML 5.

## encoding
Необязательный аргумент определяющий кодировку, используемую при конвертации симоволов.

Если не указан, то значением по умолчанию для encoding зависит от используемой версии PHP. В PHP 5.6 и старше, для значения по умолчанию используется конфигурационная опция default_charset. 

Хотя этот аргумент является технически необязательным, настоятельно рекомендуется указать правильное значение для вашего кода, если вы используете PHP 5.5 или выше, или если ваша опция конфигурации default_charset может быть задана неверно для входных данных.

Для целей этой функции кодировки ISO-8859-1, ISO-8859-15, UTF-8, cp866, cp1251, cp1252 и KOI8-R являются практически эквивалентными, предполагая то, что сама строка string содержит корректные символы в указанной кодировке, то символы, изменяемые htmlspecialchars(), останутся на тех же местах во всех этих кодировках.

Поддерживаются следующие кодировки:

- ISO-8859-1  ISO8859-1 Западно-европейская Latin-1.
- ISO-8859-5  ISO8859-5 Редко используемая кириллическая кодировка (Latin/Cyrillic).
- ISO-8859-15 ISO8859-15  Западно-европейская Latin-9. Добавляет знак евро, французские и финские буквы к кодировке Latin-1 (ISO-8859-1).
- UTF-8   8-битная Unicode, совместимая с ASCII.
- cp866 ibm866, 866 Кириллическая кодировка, применяемая в DOS.
- cp1251  Windows-1251, win-1251, 1251  Кириллическая кодировка, применяемая в Windows.
- cp1252  Windows-1252, 1252  Западно-европейская кодировка, применяемая в Windows.
- KOI8-R  koi8-ru, koi8r  Русская кодировка.
- BIG5  950 Традиционный китайский, применяется в основном на Тайване.
- GB2312  936 Упрощенный китайский, стандартная национальная кодировка.
- BIG5-HKSCS    Расширенная Big5, применяемая в Гонконге.
- Shift_JIS SJIS, SJIS-win, cp932, 932  Японская кодировка.
- EUC-JP  EUCJP, eucJP-win  Японская кодировка.
- MacRoman    Кодировка, используемая в Mac OS.
- ''    Пустая строка активирует режим определения кодировки из файла скрипта (Zend multibyte), default_charset и текущей локали в указанном порядке. Не рекомендуется к использованию.

## double_encode
Если параметр double_encode выключен, то PHP не будет преобразовывать существующие html-сущности. По умолчанию преобразуется все без ограничений.

Если входная строка string содержит неверную последовательность символов в указанной кодировке encoding, то будет возвращаться пустая строка в случае, если флаги ENT_IGNORE или ENT_SUBSTITUTE не установлены.


# implode
```
string implode ( string $glue , array $pieces )
string implode ( array $pieces )
```
Объединяет элементы массива с помощью строки glue.

## glue
По умолчанию равен пустой строке.

## pieces
Массив объединяемых строк.

Возвращает строку, содержащую строковое представление всех элементов массива в указанном порядке, со строкой glue между каждым элементом.

## Пример использования implode()

```php
<?php

$array = array('имя', 'почта', 'телефон');
$comma_separated = implode(",", $array);

echo $comma_separated; // имя,почта,телефон

// Пустая строка при использовании пустого массива:
var_dump(implode('hello', array())); // string(0) ""

?>
```

Прочитать файл, вставить переводы строк, заменить все запрещенные символы на их абривеатуру и отправить пользователю:

```php
  
  print str_replace("\n","<br />\n", htmlspecialchars(implode("\n", file( 'read_and_print.php' ) )) );

```

# $_POST

Ассоциативный массив данных, переданных скрипту через HTTP методом POST при использовании application/x-www-form-urlencoded или multipart/form-data в заголовке Content-Type запроса HTTP.

## Пример использования $_POST

```php

<?php
echo 'Привет ' . htmlspecialchars($_POST["name"]) . '!';
?>

```

Это 'суперглобальная' или автоматическая глобальная переменная. Это просто означает, что она доступна во всех контекстах скрипта. Нет необходимости выполнять global $variable; для доступа к ней внутри метода или функции.

# HTML-формы (GET и POST) 
Когда происходит отправка данных формы PHP-скрипту, информация из этой формы автоматически становится доступной ему. Существует несколько способов получения этой информации, например:

## Простая HTML-форма

```html

  <form action="foo.php" method="post">
      Имя:  <input type="text" name="username" /><br />
      Email: <input type="text" name="email" /><br />
      <input type="submit" name="submit" value="Отправь меня!" />
  </form>
```
С версии PHP 5.4.0, есть только два способа получить доступ к данным из форм HTML. Доступные сейчас способы приведены ниже:

## Доступ к данным из простой HTML-формы, отправленной через POST

```php

<?php
echo $_POST['username'];
echo $_REQUEST['username'];
?>

```

GET-форма используется аналогично, за исключением того, что вместо POST, вам нужно будет использовать соответствующую предопределенную переменную GET. GET относится также к QUERY_STRING (информация в URL после '?'). Так, например, http://www.example.com/test.php?id=3 содержит GET-данные, доступные как $_GET['id'].

Точки и пробелы в именах переменных преобразуется в знаки подчеркивания. 
Например, 

```html

  <input name="a.b" /> станет $_REQUEST["a_b"].
```
PHP также понимает массивы в контексте переменных формы. К примеру, вы можете сгруппировать связанные переменные вместе или использовать эту возможность для получения значений списка множественного выбора select. Например, давайте отправим форму самой себе, а после отправки отобразим данные:

```php

  <?php
  if ($_POST) {
      echo '<pre>';
      echo htmlspecialchars(print_r($_POST, true));
      echo '</pre>';
  }
  ?>
  <form action="" method="post">
      Имя:  <input type="text" name="personal[name]" /><br />
      Email: <input type="text" name="personal[email]" /><br />
      <input type="submit" value="Отправь меня!" />
  </form>

```
# Определение типов переменных 
Поскольку PHP определяет типы переменных и преобразует их (как правило) по мере необходимости, не всегда очевидно, какой тип имеет данная переменная в любой момент времени. PHP содержит несколько функций, позволяющих определить тип переменной, таких как: gettype(), is_array(), is_float(), is_int(), is_object() и is_string(). 

HTTP является текстовым протоколом, и большинство, если не всё, содержимое, которое приходит в cуперглобальные массивы, например $_POST и $_GET, останется в виде строк. PHP не будет преобразовывать значения в определенный тип. В приведенном ниже примере $_GET["var1"] будет содержать строку "null", а $_GET["var2"] строку "123".

```

/index.php?var1=null&var2=123

```
# !empty($_POST)
```php

  if (!empty($_POST)) {
      echo '<br><br><br><br><br><br>';
      echo '<pre>';
      echo htmlspecialchars(print_r($_POST, true));
      echo '</pre>';
  }

```
# !$_POST
```php

  if (!empty($_POST)) {
      echo '<br><br><br><br><br><br>';
      echo '<pre>';
       
       if ( !$_POST['username'] or !$_POST['email'] or !$_POST['comment']){
        echo "<b>please complete all the fields</b><br><br>";
       }
          echo "<b>please complete all the fields</b><br><br>";
      }
      else{
          echo htmlspecialchars(print_r($_POST, true));
      }
      echo '</pre>';
  }

```


# fwrite — Бинарно-безопасная запись в файл

```
int fwrite ( resource $handle , string $string [, int $length ] )
```
fwrite() записывает содержимое string в файловый поток handle.

## handle
Указатель (resource) на файл, обычно создаваемый с помощью функции fopen().

## string
Записываемая строка.

## length
Если передан аргумент length, запись остановится после того, как length байтов будут записаны или будет достигнут конец строки string, смотря что произойдёт раньше.

fwrite() возвращает количество записанных байт или FALSE в случае ошибки.

Если дескриптор handle был открыт функцией fopen() в режиме "добавление в конец", то вызовы fwrite() будут атомарными (за исключением случая, если размер string превысит размер блока файловой системы, на некоторых платформах, и пока файл хранится на локальной файловой системе). Т.е. нет необходимости блокировать ресурс с помощью flock() перед вызовом fwrite(), и все данные будут записаны без прерываний.

При повторной записи в файловый указатель, данные будут добавлены в конец содержимого файла:

```php

<?php
$fp = fopen('data.txt', 'w');
fwrite($fp, '1');
fwrite($fp, '23');
fclose($fp);

// содержимое 'data.txt' теперь 123, а не 23!
?>
```

# fputs — Псевдоним fwrite()


```php

// add comment to comments.csv

if (!empty($_POST)) {
    
    if ( !$_POST['username'] or !$_POST['email'] or !$_POST['comment']){
        echo "<b>please complete all the fields</b><br><br>";
    }
    else{
        $username = $_POST['username'];
        $email = $_POST['email'];
        $comment = $_POST['comment'];

        $appended_at = date("Y-m-d");

        // $appended_at =  date("Y/m/d");
        // $appended_at =  date("Y.m.d");
        // $appended_at =  date("Y-m-d");
        // $appended_at =  date("l");

        $handle = fopen(DB."comments.csv", "a+");

        $string = $username.":".$email.":".$comment.":".$appended_at."\r\n";

        fwrite($handle, $string);
       
        fclose($handle);

    }
    
}
```


# date_default_timezone_set

```
bool date_default_timezone_set ( string $timezone_identifier )
```
date_default_timezone_set() устанавливает временную зону по умолчанию для всех функций даты/времени в скрипте.

## timezone_identifier
Идентификатор временной зоны, как например UTC или Europe/Lisbon. Список допустимых идентификаторов временной зоны можно найти в разделе Список поддерживаемых временных зон.

Функция возвращает FALSE, если timezone_identifier имеет неверное значение, в остальных случаях TRUE.


## Получение временной зоны по умолчанию

```php

<?php
date_default_timezone_set('America/Los_Angeles');

$script_tz = date_default_timezone_get();

if (strcmp($script_tz, ini_get('date.timezone'))){
    echo 'Временная зона скрипта отличается от заданной в INI-файле.';
} else {
    echo 'Временные зоны скрипта и настройки INI-файла совпадают.';
}
?>

```

## Список поддерживаемых временных зон

http://php.net/manual/ru/timezones.php

```php

<?php
date_default_timezone_set('Europe/Kiev');
require_once realpath(__DIR__).'/../config/app.php';
require_once CORE.'Router.php';

```


# date — Форматирует вывод системной даты/времени
```
string date ( string $format [, int $timestamp = time() ] )
```
Возвращает строку, отформатированную в соответствии с указанным шаблоном format. Используется метка времени, заданная аргументом timestamp, или текущее системное время, если timestamp не задан. Таким образом, timestamp является необязательным и по умолчанию равен значению, возвращаемому функцией time().


## format
Шаблон результирующей строки (string) с датой. Также существует несколько предопределенных констант даты/времени, которые могут быть использованы вместо этих параметров. Например: DATE_RSS заменяет шаблон 'D, d M Y H:i:s'.

## День

- d День месяца, 2 цифры с ведущим нулём  от 01 до 31
- D Текстовое представление дня недели, 3 символа от Mon до Sun
- j День месяца без ведущего нуля от 1 до 31
- l (строчная 'L')  Полное наименование дня недели  от Sunday до Saturday
- N Порядковый номер дня недели в соответствии со стандартом ISO-8601
- S Английский суффикс порядкового числительного дня месяца, 2 символа  st, nd, rd или th. Применяется совместно с j
- w Порядковый номер дня недели от 0 (воскресенье) до 6 (суббота)
- z Порядковый номер дня в году (начиная с 0) От 0 до 365
## Неделя
- W Порядковый номер недели года в соответствии со стандартом ISO-8601; недели начинаются с понедельника  Например: 42 (42-я неделя года)
## Месяц
- F Полное наименование месяца, например January или March  от January до December
- m Порядковый номер месяца с ведущим нулём от 01 до 12
- M Сокращенное наименование месяца, 3 символа  от Jan до Dec
- n Порядковый номер месяца без ведущего нуля от 1 до 12
- t Количество дней в указанном месяце  от 28 до 31
## Год
- L Признак високосного года  1, если год високосный, иначе 0.
- o Номер года в соответствии со стандартом ISO-8601. Имеет то же значение, что и Y, кроме случая, когда номер недели ISO (W) принадлежит предыдущему или следующему году; тогда будет использован год этой недели. (добавлен в версии PHP 5.1.0) Примеры: 1999 или 2003
- Y Порядковый номер года, 4 цифры  Примеры: 1999, 2003
- y Номер года, 2 цифры Примеры: 99, 03
## Время
- a Ante meridiem (англ. "до полудня") или Post meridiem (англ. "после полудня") в нижнем регистре  am или pm
- A Ante meridiem или Post meridiem в верхнем регистре  AM или PM
- B Время в формате Интернет-времени (альтернативной системы отсчета времени суток) от 000 до 999
- g Часы в 12-часовом формате без ведущего нуля от 1 до 12
- G Часы в 24-часовом формате без ведущего нуля от 0 до 23
- h Часы в 12-часовом формате с ведущим нулём от 01 до 12
- H Часы в 24-часовом формате с ведущим нулём от 00 до 23
- i Минуты с ведущим нулём  от 00 до 59
- s Секунды с ведущим нулём от 00 до 59
- u Микросекунды (добавлено в версии PHP 5.2.2). Учтите, что date() всегда будет возвращать 000000, т.к. она принимает целочисленный параметр, тогда как DateTime::format() поддерживает микросекунды, если DateTime создан с ними. Например: 654321
- v Миллисекунды (добавлено в PHP 7.0.0). То же замечание справедливо и для u.  Пример: 654
## Временная зона
- e Идентификатор временной зоны (добавлен в версии PHP 5.1.0)  Примеры: UTC, GMT, Atlantic/Azores
- I (заглавная i) Признак летнего времени 1, если дата соответствует летнему времени, 0 в противном случае.
- O Разница с временем по Гринвичу, в часах Например: +0200
- P Разница с временем по Гринвичу с двоеточием между часами и минутами
- T Аббревиатура временной зоны Примеры: EST, MDT ...
- Z Смещение временной зоны в секундах. Для временных зон, расположенных западнее UTC возвращаются отрицательные числа, а расположенных восточнее UTC - положительные.  от -43200 до 50400
## Полная дата/время
- c Дата в формате стандарта ISO 8601 (добавлено в PHP 5) 2004-02-12T15:19:21+00:00
- r Дата в формате » RFC 2822 Например: Thu, 21 Dec 2000 16:01:07 +0200
- U Количество секунд, прошедших с начала Эпохи Unix (The Unix Epoch, 1 января 1970 00:00:00 GMT)
Любые другие символы, встреченные в строке-шаблоне, будут выведены в результирующую строку без изменений. Z всегда возвращает 0 при использовании gmdate().

## timestamp
Необязательный параметр timestamp представляет собой метку времени типа integer, по умолчанию равную текущему локальному времени, если timestamp не указан. 

Возвращает отформатированную строку с датой. При передаче нечислового значения в качестве параметра timestamp будет возвращено FALSE и вызвана ошибка уровня E_WARNING.

Каждый вызов к функциям даты/времени при неправильных настройках временной зоны сгенерирует ошибку уровня E_NOTICE, и/или ошибку уровня E_STRICT или E_WARNING при использовании системных настроек или переменной окружения TZ.


# file_put_contents — Пишет строку в файл
```
int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )
```
Функция идентична последовательным успешным вызовам функций fopen(), fwrite() и fclose().

Если filename не существует, файл будет создан. Иначе, существующий файл будет перезаписан, за исключением случая, если указан флаг FILE_APPEND.

## filename
Путь к записываемому файлу.

## data
Записываемые данные. Может быть типа string, array или ресурсом stream.

## flags
Значением параметра flags может быть любая комбинация следующих флагов, соединенных бинарным оператором ИЛИ (|).

### Доступные флаги

- FILE_USE_INCLUDE_PATH Ищет filename в подключаемых директориях. Подробнее смотрите директиву include_path.
- FILE_APPEND Если файл filename уже существует, данные будут дописаны в конец файла вместо того, чтобы его перезаписать.
- LOCK_EX Получить эксклюзивную блокировку на файл на время записи. Другими словами, между вызовами fopen() и fwrite() произойдет вызов функции flock(). Это не одно и то же, что вызов fopen() с флагом "x".

Функция возвращает количество записанных байт в файл, или FALSE в случае ошибки.

```php

// add comment to comments.csv

if (!empty($_POST)) {
    
    if ( !$_POST['username'] or !$_POST['email'] or !$_POST['comment']){
        echo "<b>please complete all the fields</b><br><br>";
    }
    else{
        $username = $_POST['username'];
        $email = $_POST['email'];
        $comment = $_POST['comment'];
        $appended_at = date("Y-m-d");

        $string = $username.":".$email.":".$comment.":".$appended_at."\r\n";

        file_put_contents(DB."comments.csv", $string, FILE_APPEND);

    }
}

```

# fputcsv — Форматирует строку в виде CSV и записывает её в файловый указатель

```
int fputcsv ( resource $handle , array $fields [, string $delimiter = "," [, string $enclosure = '"' [, string $escape_char = "\" ]]] )
```
fputcsv() форматирует строку (переданную в виде массива fields) в виде CSV и записывает её (заканчивая переводом строки) в указанный файл handle.

## handle
Указатель на файл должен быть корректным и указывать на файл, успешно открытый функциями fopen() или fsockopen() (и все еще не закрытым функцией fclose()).

## fields
Массив значений.

## delimiter
Дополнительный параметр delimiter устанавливает разделитель полей (только один символ).

## enclosure
Дополнительный параметр enclosure устанавливает ограничитель полей (только один символ).

## escape_char
Необязательный параметр escape_char задает экранирующий символ (только один символ).

Возвращает длину записанной строки или FALSE в случае возникновения ошибки.

```php
if (!empty($_POST)) {
    
    if ( !$_POST['username'] or !$_POST['email'] or !$_POST['comment']){
        echo "<b>please complete all the fields</b><br><br>";
    }
    else{
        $fields = [];

        $username = $_POST['username'];

        array_push($fields,$username); 
        $email = $_POST['email'];
        array_push($fields,$email); 
        $comment = $_POST['comment'];
        array_push($fields,$comment); 
        $appended_at = date("Y-m-d");
        array_push($fields,$appended_at); 

        $handle = fopen(DB."comments.csv", "a+");

        $string = $username.":".$email.":".$comment.":".$appended_at."\r\n";

        fputcsv($handle, $fields, ':');

        fclose($handle);

    }
    
}

```

# fgetcsv — Читает строку из файла и производит разбор данных CSV
```
array fgetcsv ( resource $handle [, int $length = 0 [, string $delimiter = "," [, string $enclosure = '"' [, string $escape = "\" ]]]] )
```
Данная функция похожа на функцию fgets(), с той разницей, что она производит анализ строки на наличие записей в формате CSV и возвращает найденные поля в качестве массива.

## handle
Корректный файловый указатель на файл, успешно открытый при помощи fopen(), popen() или fsockopen().

## length
Должен быть больше самой длинной строки (в символах), найденной в CSV-файле (включая завершающий символ конца строки). В противном случае, строка будет разбита на куски длиной в length символов если только место разрыва не будет внутри ограничителей полей (enclosure).

Опускание этого параметра (или установка его в 0) приведет к тому, что длина строки будет неограничена. Это может сказаться на скорости выполнения.

## delimiter
Необязательный параметр delimiter устанавливает разделитель поля (только один символ).

## enclosure
Необязательный параметр enclosure устанавливает символ ограничителя поля (только один символ).

## escape
Необязательный параметр escape устанавливает экранирующий символ (только один символ).

Возвращает индексированный массив с прочтенными полями.

fgetcsv() возвращает NULL, если передаётся неверный параметр handle или FALSE при других ошибках, в том числе и по достижении конца файла.

```php
    $comments = [];

    $handle = fopen(DB."comments.csv", "rt");


    while (($row = fgetcsv($handle , 10000, ":")) !== FALSE) 
    { 
        array_push($comments,$row); 
        
    } 

    fclose($handle); 
```

```php

    <?php 
       echo '<pre>';
                
       echo htmlspecialchars(print_r($comments, true));
                 
       echo '</pre>';

```                


```php
     
     foreach ($comments as $key => $value) {
       echo "<div class='top'><b>User ".$value[0]."</b> <a href='mailto:".$value[1]."'>".$value[1]."</a> Added this </div>"; 
       echo "<div class='comment'>".strip_tags($value[2])."</div>"; 
       echo "<div class='added_at'> At: ".strip_tags($value[3])."</div>"; 
     }
 
```
