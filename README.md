# shopping-cart 

# Массивы (Array)

Массивы (arrays) - это упорядоченные наборы данных, представляющие собой список однотипных элементов.

Существует два типа массивов, различающиеся по способу идентификации элементов.

1. В массивах первого типа элемент определяется индексом в последовательности. Такие массивы называются простыми массивами (список, вектор).

2. Массивы второго типа имеют ассоциативную природу, и для обращения к элементам используются ключи, логически связанные со значениями. Такие массивы называют ассоциативными массивами  (хэш-таблица, словарь, коллекция, стэк, очередь).


Массивы могут быть как одномерными, так и многомерными.
Так как значением массива может быть другой массив PHP, можно также создавать деревья и многомерные массивы.

## Простые массивы и списки в PHP

При обращении к элементам простых индексируемых массивов используется целочисленный индекс, определяющий позицию заданного элемента.

## Простые одномерные массивы:

```

$имя[индекс];

```

Массивы, индексами которых являются числа, начинающиеся с нуля - это списки


## Ассоциативные массивы в PHP

В PHP индексом массива может быть не только число, но и строка. Причем на такую строку не накладываются никакие ограничения: она может содержать пробелы, длина такой строки может быть любой.

Ассоциативные массивы особенно удобны в ситуациях, когда элементы массива удобнее связывать со словами, а не с числами.

## Определение при помощи array()

Массив (тип array) может быть создан языковой конструкцией array(). В качестве параметров она принимает любое количество разделенных запятыми пар key => value (ключ => значение).

```php

    array(
    key  => value,
    key2 => value2,
    key3 => value3,
    ...
    )
```
Запятая после последнего элемента массива необязательна и может быть опущена. Обычно это делается для однострочных массивов, т.е. array(1, 2) предпочтительней array(1, 2, ).

Начиная с PHP 5.4 возможно использовать короткий синтаксис определения массивов, который заменяет языковую конструкцию array() на [].

## Простой массив

```php

<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
);

// Начиная с PHP 5.4
$array = [
    "foo" => "bar",
    "bar" => "foo",
];
?>
```

key может быть либо типа integer, либо типа string. value может быть любого типа.

Дополнительно с ключом key будут сделаны следующие преобразования:

- Строки, содержащие целое число (исключая случаи, когда число предваряется знаком +) будут преобразованы к типу integer. Например, ключ со значением "8" будет в действительности сохранен со значением 8. С другой стороны, значение "08" не будет преобразовано, так как оно не является корректным десятичным целым.
- Числа с плавающей точкой (тип float) также будут преобразованы к типу integer, т.е. дробная часть будет отброшена. Например, ключ со значением 8.7 будет в действительности сохранен со значением 8.
- Тип bool также преобразовываются к типу integer. Например, ключ со значением true будет сохранен со значением 1 и ключ со значением false будет сохранен со значением 0.
- Тип null будет преобразован к пустой строке. Например, ключ со значением null будет в действительности сохранен со значением "".
- Массивы (тип array) и объекты (тип object) не могут использоваться в качестве ключей. При подобном использовании будет генерироваться предупреждение: Недопустимый тип смещения (Illegal offset type).

Если несколько элементов в объявлении массива используют одинаковый ключ, то только последний будет использоваться, а все другие будут перезаписаны.

## Пример преобразования типов и перезаписи элементов

```php 

<?php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d",
);
var_dump($array);
?>

```

Результат выполнения данного примера:

```php 

array(1) {
  [1]=>
  string(1) "d"
}

```

Так как все ключи в вышеприведенном примере преобразуются к 1, значение будет перезаписано на каждый новый элемент и останется только последнее присвоенное значение "d".

Массивы в PHP могут содержать ключи типов integer и string одновременно, так как PHP не делает различия между индексированными и ассоциативными массивами.

## Смешанные ключи типов integer и string

```php

<?php
$array = array(
    "foo" => "bar",
    "bar" => "foo",
    100   => -100,
    -100  => 100,
);
var_dump($array);
?>

```

Параметр key является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа integer, увеличенное на 1.

## Индексированные массивы без ключа

```php

<?php
$array = array("foo", "bar", "hallo", "world");
var_dump($array);
?>

```

Возможно указать ключ только для некоторых элементов и пропустить для других:

```php

<?php
$array = array(
         "a",
         "b",
    6 => "c",
         "d",
);
var_dump($array);
?>

```

Как вы видите последнее значение "d" было присвоено ключу 7. Это произошло потому, что самое большое значение ключа целого типа перед этим было 6.


## Доступ к элементам массива с помощью квадратных скобок 

Доступ к элементам массива может быть осуществлен с помощью синтаксиса array[key].

### Доступ к элементам массива
```php

<?php

    $array = array(
        "foo" => "bar",
        42    => 24,
        "multi" => array(
             "dimensional" => array(
                 "array" => "foo"
             )
        )
    );

    var_dump($array["foo"]);
    var_dump($array[42]);
    var_dump($array["multi"]["dimensional"]["array"]);
    ?>

```

И квадратные и фигурные скобки можно взаимозаменяемо использовать для доступа к элементам массива (т.е. и $array[42] и $array{42} равнозначны).


# Ассоциативный массив $GLOBALS

$GLOBALS - это ассоциативный массив, ключом которого является имя, а значением - содержимое глобальной переменной. 

### способ доступа к переменным глобальной области видимости

```php

<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
} 

Sum();
echo $b;
?>
```

$GLOBALS существует в любой области видимости, это объясняется тем, что $GLOBALS является суперглобальным. 

### Суперглобальные переменные и область видимости

```php

<?php
function test_global()
{
    // Большинство предопределенных переменных не являются
    // "супер", и чтобы быть доступными в локальной области
    // видимости, функции требуют указания 'global'.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // Суперглобальные переменные доступны в любой области
    // видимости и не требуют указания 'global'.
    // Суперглобальные переменные доступны, начиная с PHP 4.1.0, а
    // использование HTTP_POST_VARS считается устаревшим.
    echo $_POST['name'];
}
?>
```

# Суперглобальный массив $_SERVER

## Информация о сервере и среде исполнения

Переменная $_SERVER - это массив, содержащий информацию, такую как заголовки, пути и местоположения скриптов. Записи в этом массиве создаются веб-сервером. Нет гарантии, что каждый веб-сервер предоставит любую из них; сервер может опустить некоторые из них или предоставить другие, не указанные здесь. 

Просмотреть полный список элементов массива $_SERVER можно либо при помощи функции print_r(), которая распечатывает дамп массива либо при помощи функции phpinfo(), которая выводит информацию о PHP-интерпретаторе.

Это 'суперглобальная' или автоматическая глобальная переменная, она доступна во всех контекстах скрипта. Нет необходимости выполнять global $variable; для доступа к ней внутри метода или функции.

## Индексы 

- 'PHP_SELF'
    Имя файла скрипта, который сейчас выполняется, относительно корня документов. Например,$_SERVER['PHP_SELF'] в скрипте по адресу http://example.com/foo/bar.php будет /foo/bar.php. Константа __FILE__ содержит полный путь и имя файла текущего (то есть подключенного) файла. Если PHP запущен в командной строке, эта переменная содержит имя скрипта, начиная с PHP 4.3.0. Раньше она была недоступна. 
- 'argv'
    Массив агрументов, переданных скрипту. Когда скрипт запущен в командой строке, это дает C-подобный доступ к параметрам командной строки. Когда вызывается через метод GET, этот массив будет содержать строку запроса. 
- 'argc'
    Содержит количество параметров, переданных скрипту (если запуск произведен в командной строке). 
- 'GATEWAY_INTERFACE'
    Содержит используемую сервером версию спецификации CGI; к примеру'CGI/1.1'. 
- 'SERVER_ADDR'
    IP-адрес сервера, на котором выполняется текущий скрипт. 
- 'SERVER_NAME'
    Имя хоста, на котором выполняется текущий скрипт. Если скрипт выполняется на виртуальном хосте, здесь будет содержатся имя, определенное для этого виртуального хоста.
- 'SERVER_SOFTWARE'
    Строка идентификации сервера, указанная в заголовках, когда происходит ответ на запрос. 
- 'SERVER_PROTOCOL'
    Имя и версия информационного протокола, через который была запрошена страница; к примеру 'HTTP/1.0'; 
- 'REQUEST_METHOD'
    Какой метод был использован для запроса страницы; к примеру 'GET', 'HEAD', 'POST', 'PUT'.
- 'REQUEST_TIME'
    Временная метка начала запроса. Доступна, начиная с PHP 5.1.0. 
- 'REQUEST_TIME_FLOAT'
    Временная метка начала запроса с точностью до микросекунд. Доступна, начиная с PHP 5.4.0. 
- 'QUERY_STRING'
    Строка запросов, если есть, с помощью которой была получена страница. 
- 'DOCUMENT_ROOT'
    Директория корня документов, в которой выполняется текущий скрипт, в точности та, которая указана в конфигурационном файле сервера. 
- 'HTTP_ACCEPT'
    Содержимое заголовка Accept: из текущего запроса, если он есть. 
- 'HTTP_ACCEPT_CHARSET'
    Содержимое заголовка Accept-Charset: из текущего запроса, если он есть. Например: 'iso-8859-1,*,utf-8'. 
- 'HTTP_ACCEPT_ENCODING'
    Содержимое заголовка Accept-Encoding: из текущего запроса, если он есть. Например: 'gzip'. 
- 'HTTP_ACCEPT_LANGUAGE'
    Содержимое заголовка Accept-Language: из текущего запроса, если он есть. Например: 'en'. 
- 'HTTP_CONNECTION'
    Содержимое заголовка Connection: из текущего запроса, если он есть. Например: 'Keep-Alive'. 
- 'HTTP_HOST'
    Содержимое заголовка Host: из текущего запроса, если он есть. 
- 'HTTP_REFERER'
    Адрес страницы (если есть), которая привела браузер пользователя на эту страницу. Этот заголовок устанавливается веб-браузером пользователя. Не все браузеры устанавливают его и некоторые в качестве дополнительной возможности позволяют изменять содержимое заголовка HTTP_REFERER. Одним словом, в самом деле ему нельзя доверять. 
- 'HTTP_USER_AGENT'
    Содержимое заголовка User-Agent: из текущего запроса, если он есть. Эта строка содержит обозначение браузера, которым пользователь запросил данную страницу. 
- 'HTTPS'
    Принимает непустое значение, если запрос был произведен через протокол HTTPS.
- 'REMOTE_ADDR'
    IP-адрес, с которого пользователь просматривает текущую страницу. 
- 'REMOTE_HOST'
    Удаленный хост, с которого пользователь просматривает текущую страницу. Обратный просмотр DNS базируется на значении переменной REMOTE_ADDR.
- 'REMOTE_PORT'
    Порт на удаленной машине, который используется для связи с веб-сервером. 
- 'REMOTE_USER'
    Аутентифицированный пользователь. 
- 'REDIRECT_REMOTE_USER'
    Аутентифицированный пользователь, если запрос был перенаправлен изнутри. 
- 'SCRIPT_FILENAME'
    Абсолютный путь к скрипту, который в данный момент исполняется.
- 'SERVER_ADMIN'
    Эта переменная получает свое значение (для Apache) из директивы конфигурационного файла сервера. Если скрипт запущен на виртуальном хосте, это будет значение, определенное для данного виртуального хоста. 
- 'SERVER_PORT'
    Порт на компьютере сервера, используемый веб-сервером для соединения. Для установок по умолчанию, значение будет '80'; используя SLL, например, это значение будет таким, какое сконфигурировано для соединений безопасного HTTP.
- 'SERVER_SIGNATURE'
    Строка, содержащая версию сервера и имя виртуального хоста, которые добавляются к генерируемым сервером страницам, если включено. 
- 'PATH_TRANSLATED'
    Путь файловой системы (не document root) к текущему скрипту, после того как сервер выполнил отображение virtual-to-real.
- 'SCRIPT_NAME'
    Содержит путь, к текущему исполняемому скрипту. Это полезно для страниц, которые должны указывать на самих себя. Константа __FILE__ содержит полный путь и имя текущего (т.е. включаемого) файла. 
- 'REQUEST_URI'
    URI, который был передан для того, чтобы получить доступ к этой странице. Например, '/index.html'. 
- 'PHP_AUTH_DIGEST'
    При выполнении HTTP Digest аутентификации, этой переменной присваивается заголовок 'Authorization', который присылается клиентом (его необходимо потом использовать для соответствующей валидации). 
- 'PHP_AUTH_USER'
    Когда выполняется HTTP-аутентификация, этой переменной присваивается имя пользователя, предоставленное пользователем. 
- 'PHP_AUTH_PW'
    Когда выполняется HTTP-аутентификация, этой переменной присваивается пароль, предоставленный пользователем. 
- 'AUTH_TYPE'
    Когда выполняется HTTP-аутентификация, этой переменной присваивается тип аутентификации, который используется. 
- 'PATH_INFO'
    Содержит любой предоставленный пользователем путь, содержащийся после имени скрипта, но до строки запроса, если таковая имеется. Например, если текущий скрипт запрошен по URL http://www.example.com/php/path_info.php/some/stuff?foo=bar, то переменная $_SERVER['PATH_INFO'] будет содержать /some/stuff. 
- 'ORIG_PATH_INFO'
    Исходное значение переменной 'PATH_INFO' до начала обработки PHP. 


## Использование элементов массива $_SERVER

```php 

    <?php
      echo "Имя сервера - ".$_SERVER['SERVER_NAME']."<br />";
      echo "IP-адрес сервера - ".$_SERVER['SERVER_ADDR']."<br />";
      echo "Порт сервера - ".$_SERVER['SERVER_PORT']."<br />";
      echo "Web-сервер - ".$_SERVER['SERVER_SOFTWARE']."<br />";
      echo "Версия HTTP-протокола - ".$_SERVER['SERVER_PROTOCOL']."<br />";
    ?>
```

## Полный адрес к скрипту

В $_SERVER['REQUEST_URI'] содержит имя скрипта, начиная от корневой директории виртуального хоста и параметры, т.е. если строка запроса представляет собой адрес

```php

    <?php
      echo "http://".$_SERVER['SERVER_NAME'].$_SERVER['REQUEST_URI'];
    ?> 

```

# Подключение файлов


Чтобы сделать программный код более удобочитаемым, вы можете поместить определения функций и/или классов в отдельный файл. Возможность подключения файлов в PHP обеспечивают четыре языковые инструкции.

## Функции подключения файлов

- include – включает и выполняет указанный файл, если не находит – выдаёт предупреждение E_WARNING
- include_once – аналогично функции выше, но включает файл единожды
- require – включает и выполняет указанный файл, если не находит – выдаёт фатальную ошибку E_ERROR
- require_once – аналогично функции выше, но включает файл единожды

В действительности, это не совсем функции, это специальные языковые конструкции. 

Все четыре инструкции могут принимать в качестве параметра имя локального файла. Инструкция include и require очень схожи по действию и отличаются лишь реакцией на невозможность получения запрошенного ресурса. 

Например, в случае недоступности ресурса include и include_once выводят предупреждение и пытаются продолжить исполнение программы. require и require_once при недоступности запрошенного ресурса останавливают обработку данной страницы.


## Путь к файлу

PHP ищет подключаемые файлы в директориях прописанных в директиве include_path (в конфигурационном файле php.ini). Эта директива также влияет на работу функций fopen(), file(), readfile() и file_get_contents(). 
Алгоритм работы достаточно простой – при поиске файлов PHP по очереди проверяет каждую директорию из include_path, пока не найдет подключаемый файл. Если файл не найден по указанному пути в include_path, инструкция include попытается проверить текущую рабочую директорию, в которой находится скрипт подключающий файл, если конструкция include не сможет найти файл, будет выдано предупреждение (warning). 

Если путь указан - не важно какой: абсолютный или относительный (относительно текущей директории, где расположен включающий сценарий) - директива include_path будет проигнорирована.

Для изменения include_path из скрипта следует использовать функцию set_include_path().

При настройке include_path следует учитывать один важный момент – в качестве разделителя путей в Windows и Linux используются различные символы – “;” и “:” соответственно, так что при указании своей директории используйте константу PATH_SEPARATOR, например:

```php

// пример пути в linux
$path = '/home/dev/library';
 
// пример пути в windows
$path = 'c:\Users\Dev\Library';
 
// для linux и windows код изменение include_path идентичный
set_include_path(get_include_path() . PATH_SEPARATOR . $path);

Когда вы прописываете include_path в ini файле, то можете использовать переменные окружения типа ${USER}:

include_path = ".:${USER}/my-php-library"

```

# realpath — канонизированный абсолютный путь к файлу

```php

string realpath ( string $path )

```
realpath() раскрывает все символические ссылки, переходы типа '/./', '/../' и лишние символы '/' в пути path, возвращая канонизированный абсолютный путь к файлу.

## Список параметров

- path - Проверяемый путь.

Несмотря на то, что путь должен быть указан, переданное значение может быть пустой строкой или NULL. В этих случаях значение интерпретируется как текущая рабочая директория.

В случае успеха возвращает канонизированный абсолютный путь. Результирующий путь не содержит символических ссылок и компонентов наподобие '/./' или '/../'. Разделители \ и / в конце пути так же удаляются.

realpath() возвращает FALSE при неудаче, например, если файл не существует.

Запускаемый скрипт должен иметь права запуска на всех директориях в проверяемой иерархии, иначе realpath() вернет FALSE.

Для регистронезависимых файловых систем, realpath() может нормализовать или не нормализовать регистр символов.


## Пример использования функции realpath()


```php 

<?php

  include realpath(__DIR__).'/../views/home/index.php';

```

# Инструкции include и include_once

## Инструкция include в PHP

Инструкции include и include_once предназначены для подключения дополнительных файлов, например конфигурационного файла, или файла обработчика вводимых данных, или ротатора баннеров, или блока комментариев, или других PHP-скриптов или чего угодно, что нужно для сайта. Естественно это позволяет разбивать объемные многострочные файлы на множество мелких, с которыми проще работать.

При запуске программы интерпретатор просто заменит инструкцию на содержимое подключаемого файла. 

При обработке интерпретатором кода составленного на инструкции include, загрузка страницы не прерывается при сбое


## Синтаксис подключения инструкции include:

```php

include 'map.php'; 

// map.php - нужный файл, который может состоять из сотни строк кода 

```
Инструкция include_once работает по тому же принципу, но она защищает программиста от ошибки повторного включения одного о того же файла. Например файл конфигурации на странице нужен только один раз, его и можно подключить при помощи данной инструкции, а если случайно будет повторное включение, то выполнятся данный код будет только один раз, что довольно удобно. Потому и суффикс once означает - лишь один раз

## Синтаксис инструкции include_once :

```php

 include_once 'config.php'; 
 // config.php - файл, который нужно подключить только один раз

```

Инструкция include позволяет подключать и присоединять к вашему PHP-сценарию другие сценарии. 

```php


switch ($_SERVER['REQUEST_URI']) {

    case '/':
        # code...
        include realpath(__DIR__).'/../views/home/index.php';
        break;


    default:
         echo "<h1>404</h1>";
}

```

Особенностью подключения файлов является тот момент, что при подключении файла парсинг переключается в режим HTML, по этой причине любой код внутри включаемого файла должен быть заключен в PHP теги:

```html

  <?php
  // подключаемый код 
  // ...
  //
  ?>

```

вы можете присваивать подключаемым файлам любые имена, но всегда добавляйте расширение .php, потому что при использовании другого расширения, злоумышленники могут запросить ваш файл, и веб-сервер вернет его текст. Это угроза безопасности, поскольку могут быть раскрыты пароли или принцип действия вашей программы, что дает лазейку злоумышленникам. Чтобы этого не происходило, подключаемые файлы должны обрабатываться интерпретатором PHP.


## include_once
Поведение include_once идентично инструкции include, с той лишь разницей, что если код из файла уже был один раз подключен, он не будет подключен и выполнен повторно. Это помогает избежать проблемы с переопределением функций, переменных и т.д. 

```php


    case '/about':
        # code...
        include_once realpath(__DIR__).'/../views/home/about.php';
        break;
```


## Инструкции require и require_once

Инструкции require и require_once работают идентично include и include_once за исключением лишь одной особенности. Если подключаемый файл не будет найден, выполнение скрипта будет остановлено, в то время как include и include_once выводят предупреждение и продолжают выполнение скрипта.


При обработке кода, PHP сначала преобразует сценарий во внутреннее представление, после чего начинается обработка кода строчка за строчкой. И если PHP находит в коде файл, включаемый инструкцией include, то он после загрузки файла полностью переключается на его выполнение, преобразует файл во внутреннее представление, а уже потом поэтапно его выполняет...

Подключенный с помощью require файл, транслируется до выполнения сценария, другими словами, на момент обработки всего кода, этот файл уже оттранслирован! файлы подключенные инструкцией require - будут работать быстрее. 

При загрузке страницы браузером, может произойти сбой интернета и пользователь может увидеть только ту часть страницы, которая успела загрузиться. Или при каком то сбое в обработке, дальше зависшего файла обработка не пойдет. 

Инструкция require_once - также выполняет роль для включения файла в общий код только один раз, чтобы не было повторений.

Синтаксис данных инструкций такой:

```php

switch ($_SERVER['REQUEST_URI']) {

    case '/':
        # code...
        require_once CONTROLLERS.'HomeController.php';
        break;

    case '/about':
        # code...
        require_once CONTROLLERS.'AboutController.php';;
        break;

```

Когда файл подключается, то его код оказывается в той же области видимости, что и строка в которой его подключили, таким образом все переменные, доступные в данной строке будут доступны и в подключаемом файле. 

Если вы подключаете файл внутри функции, то подключаемые файлы получают доступ к области видимости функции, таким образом следующий код тоже будет работать:

# Константы

Константы - это идентификаторы (имена) простых значений. Имена констант чувствительны к регистру. По принятому соглашению, имена констант всегда пишутся в верхнем регистре.

Имя константы должно соответствовать тем же правилам, что и другие имена в PHP. Правильное имя начинается с буквы или символа подчеркивания и состоит из букв, цифр и подчеркиваний. Регулярное выражение для проверки правильности имени константы выглядит так: 

```js

  [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*
```

## Правильные и неправильные имена констант
```php

    <?php

    // Правильные имена констант
    define("FOO",     "something");
    define("FOO2",    "something else");
    define("FOO_BAR", "something more");

    // Неправильные имена констант
    define("2FOO",    "something");

    // Это корректное объявление, но лучше его не использовать:
    // PHP однажды может зарегистрировать волшебную константу,
    // которая сломает ваш скрипт
    define("__FOO__", "something");

    ?>
```

Константы доступны из любой области видимости. Вы можете использовать константы в любом месте вашего скрипта, не обращая внимания на текущую область видимости. 

# Волшебные константы 

PHP предоставляет большой список предопределенных констант для каждого выполняемого скрипта. Многие из этих констант определяются различными модулями и будут присутствовать только в том случае, если эти модули доступны в результате динамической загрузки или в результате статической сборки.

Все волшебные константы разрешаются во время компиляции, в отличие от обычных констант, которые разрешаются во время исполнения. Специальные константы нечувствительны к регистру:

## Некоторые волшебные константы PHP

- __LINE__  Текущий номер строки в файле.

- __FILE__  Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.

- __DIR__ Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.

- __FUNCTION__  Имя функции.

- __CLASS__ Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). 

- __TRAIT__ Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).

- __METHOD__  Имя метода класса.

- __NAMESPACE__ Имя текущего пространства имен.



# Реализация минимального сайта

## Создаем файл настроек


## config/app.php

```php

<?php
  
  define('ROOT', realpath(__DIR__.'/../'));
  define('VIEWS', ROOT.'/views/');
  define('CONTROLLERS', ROOT.'/controllers/');
  define('CONFIG', ROOT.'/config/');
  define('CORE', ROOT.'/core/');
  define('APPNAME', 'Great Shopaholic');
  define('SLOGAN', 'Lets Build Cool Site');

```

## Создаем файл маршрутов Router.php

```php

  <?php

  switch ($_SERVER['REQUEST_URI']) {

      case '/':
          # code...
          require_once CONTROLLERS.'HomeController.php';
          break;

      case '/about':
          # code...
          require_once CONTROLLERS.'AboutController.php';;
          break;

      default:
          # code...
          echo "<h1>404</h1>";
  }

```

## Создаем файл контроллера HomeController.php

```php

  <?php

  require_once VIEWS.'home/index.php';

```

## Создаем файл представления home/index.php

```html

  <?php

  require_once VIEWS.'shared/head.php';
  require_once VIEWS.'shared/navigation.php';
  ?>
  <!-- product Start -->
  <section class="product">
      <div class="container">
          <div class="row">
              <div class="col-md-12">
                  <div class="feature_header text-center">
                      <h3 class="feature_title">Our <b>Cat Members</b></h3>
                      <h4 class="feature_sub">Lorem ipsum dolor sit amet, consectetur adipisicing elit. </h4>
                      <div class="divider"></div>
                  </div>
              </div>  <!-- Col-md-12 End -->
              <div class="product-items">


              </div>
          </div>
      </div> <!-- Conatiner product end -->
  </section>  <!-- Section product End -->

  <!-- Our product End -->
  <div class="clearfix"></div>

  <?php

  require_once VIEWS.'shared/footer.php';

  ?>

```

## Создаем файл загрузки приложения bootstrap/bootstrap.php

```php

    <?php
    require_once realpath(__DIR__).'/../config/app.php';
    require_once CORE.'Router.php';

```
## Стартуем приложение index.php

```php

    require_once realpath(__DIR__).'/../bootstrap/bootstrap.php';

```
