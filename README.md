# shopping-cart 

# Область видимости переменной

Область видимости переменной - это контекст, в котором эта переменная определена. В большинстве случаев все переменные PHP имеют только одну область видимости. Эта единая область видимости охватывает также включаемые (include) и требуемые (require) файлы.
```php

<?php
$a = 1;
include 'b.inc';
?>
```
Здесь переменная $a будет доступна внутри включенного скрипта b.inc. 

Определение (тело) пользовательской функции задает локальную область видимости данной функции. 

Любая используемая внутри функции переменная по умолчанию ограничена локальной областью видимости функции. Например:

```php

<?php
$a = 1; /* глобальная область видимости */ 

function test()
{ 
    echo $a; /* ссылка на переменную локальной области видимости */ 
} 

test();
?>
```

Этот скрипт не сгенерирует никакого вывода, поскольку выражение echo указывает на локальную версию переменной $a, а в пределах этой области видимости ей не было присвоено значение. В PHP, если глобальная переменная будет использоваться внутри функции, она должна быть объявлена глобальной внутри определения функции.

## Ключевое слово global 


### Использование global

```php

<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?>
```

Вышеприведенный скрипт выведет 3. После определения $a и $b внутри функции как global все ссылки на любую из этих переменных будут указывать на их глобальную версию. Не существует никаких ограничений на количество глобальных переменных, которые могут обрабатываться функцией.

Второй способ доступа к переменным глобальной области видимости - использование специального, определяемого PHP массива $GLOBALS. Предыдущий пример может быть переписан так:

### Использование $GLOBALS вместо global

```php

<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
} 

Sum();
echo $b;
?>
```

$GLOBALS - это ассоциативный массив, ключом которого является имя, а значением - содержимое глобальной переменной. Обратите внимание, что $GLOBALS существует в любой области видимости, это объясняется тем, что $GLOBALS является суперглобальным. Ниже приведен пример, демонстрирующий возможности суперглобальных переменных:

### Суперглобальные переменные и область видимости

```php

<?php
function test_global()
{
    // Большинство предопределенных переменных не являются
    // "супер", и чтобы быть доступными в локальной области
    // видимости, функции требуют указания 'global'.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // Суперглобальные переменные доступны в любой области
    // видимости и не требуют указания 'global'.
    // Суперглобальные переменные доступны, начиная с PHP 4.1.0, а
    // использование HTTP_POST_VARS считается устаревшим.
    echo $_POST['name'];
}
?>
```

# Подключение файлов


Чтобы сделать программный код более удобочитаемым, вы можете поместить определения функций и/или классов в отдельный файл. Возможность подключения файлов в PHP обеспечивают четыре языковые инструкции.

## Функции подключения файлов

- include – включает и выполняет указанный файл, если не находит – выдаёт предупреждение E_WARNING
- include_once – аналогично функции выше, но включает файл единожды
- require – включает и выполняет указанный файл, если не находит – выдаёт фатальную ошибку E_ERROR
- require_once – аналогично функции выше, но включает файл единожды

В действительности, это не совсем функции, это специальные языковые конструкции. 

Все четыре инструкции могут принимать в качестве параметра имя локального файла. Инструкция include и require очень схожи по действию и отличаются лишь реакцией на невозможность получения запрошенного ресурса. 

Например, в случае недоступности ресурса include и include_once выводят предупреждение и пытаются продолжить исполнение программы. require и require_once при недоступности запрошенного ресурса останавливают обработку данной страницы.


## Путь к файлу

PHP ищет подключаемые файлы в директориях прописанных в директиве include_path (в конфигурационном файле php.ini). Эта директива также влияет на работу функций fopen(), file(), readfile() и file_get_contents(). 
Алгоритм работы достаточно простой – при поиске файлов PHP по очереди проверяет каждую директорию из include_path, пока не найдет подключаемый файл. Если файл не найден по указанному пути в include_path, инструкция include попытается проверить текущую рабочую директорию, в которой находится скрипт подключающий файл, если конструкция include не сможет найти файл, будет выдано предупреждение (warning). 

Если путь указан - не важно какой: абсолютный или относительный (относительно текущей директории, где расположен включающий сценарий) - директива include_path будет проигнорирована.

Для изменения include_path из скрипта следует использовать функцию set_include_path().

При настройке include_path следует учитывать один важный момент – в качестве разделителя путей в Windows и Linux используются различные символы – “;” и “:” соответственно, так что при указании своей директории используйте константу PATH_SEPARATOR, например:

```php

// пример пути в linux
$path = '/home/dev/library';
 
// пример пути в windows
$path = 'c:\Users\Dev\Library';
 
// для linux и windows код изменение include_path идентичный
set_include_path(get_include_path() . PATH_SEPARATOR . $path);

Когда вы прописываете include_path в ini файле, то можете использовать переменные окружения типа ${USER}:

include_path = ".:${USER}/my-php-library"

```

# realpath — канонизированный абсолютный путь к файлу

```php

string realpath ( string $path )

```
realpath() раскрывает все символические ссылки, переходы типа '/./', '/../' и лишние символы '/' в пути path, возвращая канонизированный абсолютный путь к файлу.

## Список параметров

- path - Проверяемый путь.

Несмотря на то, что путь должен быть указан, переданное значение может быть пустой строкой или NULL. В этих случаях значение интерпретируется как текущая рабочая директория.

В случае успеха возвращает канонизированный абсолютный путь. Результирующий путь не содержит символических ссылок и компонентов наподобие '/./' или '/../'. Разделители \ и / в конце пути так же удаляются.

realpath() возвращает FALSE при неудаче, например, если файл не существует.

Запускаемый скрипт должен иметь права запуска на всех директориях в проверяемой иерархии, иначе realpath() вернет FALSE.

Для регистронезависимых файловых систем, realpath() может нормализовать или не нормализовать регистр символов.


## Пример использования функции realpath()


```php 

<?php

  include realpath(__DIR__).'/../views/home/index.php';

```

# Инструкции include и include_once

## Инструкция include в PHP

Инструкции include и include_once предназначены для подключения дополнительных файлов, например конфигурационного файла, или файла обработчика вводимых данных, или ротатора баннеров, или блока комментариев, или других PHP-скриптов или чего угодно, что нужно для сайта. Естественно это позволяет разбивать объемные многострочные файлы на множество мелких, с которыми проще работать.

При запуске программы интерпретатор просто заменит инструкцию на содержимое подключаемого файла. 

При обработке интерпретатором кода составленного на инструкции include, загрузка страницы не прерывается при сбое


## Синтаксис подключения инструкции include:

```php

include 'map.php'; 

// map.php - нужный файл, который может состоять из сотни строк кода 

```
Инструкция include_once работает по тому же принципу, но она защищает программиста от ошибки повторного включения одного о того же файла. Например файл конфигурации на странице нужен только один раз, его и можно подключить при помощи данной инструкции, а если случайно будет повторное включение, то выполнятся данный код будет только один раз, что довольно удобно. Потому и суффикс once означает - лишь один раз

## Синтаксис инструкции include_once :

```php

 include_once 'config.php'; 
 // config.php - файл, который нужно подключить только один раз

```

Инструкция include позволяет подключать и присоединять к вашему PHP-сценарию другие сценарии. 

```php


switch ($_SERVER['REQUEST_URI']) {

    case '/':
        # code...
        include realpath(__DIR__).'/../views/home/index.php';
        break;


    default:
         echo "<h1>404</h1>";
}

```

Особенностью подключения файлов является тот момент, что при подключении файла парсинг переключается в режим HTML, по этой причине любой код внутри включаемого файла должен быть заключен в PHP теги:

```html

  <?php
  // подключаемый код 
  // ...
  //
  ?>

```

вы можете присваивать подключаемым файлам любые имена, но всегда добавляйте расширение .php, потому что при использовании другого расширения, злоумышленники могут запросить ваш файл, и веб-сервер вернет его текст. Это угроза безопасности, поскольку могут быть раскрыты пароли или принцип действия вашей программы, что дает лазейку злоумышленникам. Чтобы этого не происходило, подключаемые файлы должны обрабатываться интерпретатором PHP.


## include_once
Поведение include_once идентично инструкции include, с той лишь разницей, что если код из файла уже был один раз подключен, он не будет подключен и выполнен повторно. Это помогает избежать проблемы с переопределением функций, переменных и т.д. 

```php


    case '/about':
        # code...
        include_once realpath(__DIR__).'/../views/home/about.php';
        break;
```


## Инструкции require и require_once

Инструкции require и require_once работают идентично include и include_once за исключением лишь одной особенности. Если подключаемый файл не будет найден, выполнение скрипта будет остановлено, в то время как include и include_once выводят предупреждение и продолжают выполнение скрипта.


При обработке кода, PHP сначала преобразует сценарий во внутреннее представление, после чего начинается обработка кода строчка за строчкой. И если PHP находит в коде файл, включаемый инструкцией include, то он после загрузки файла полностью переключается на его выполнение, преобразует файл во внутреннее представление, а уже потом поэтапно его выполняет...

Подключенный с помощью require файл, транслируется до выполнения сценария, другими словами, на момент обработки всего кода, этот файл уже оттранслирован! файлы подключенные инструкцией require - будут работать быстрее. 

При загрузке страницы браузером, может произойти сбой интернета и пользователь может увидеть только ту часть страницы, которая успела загрузиться. Или при каком то сбое в обработке, дальше зависшего файла обработка не пойдет. 

Инструкция require_once - также выполняет роль для включения файла в общий код только один раз, чтобы не было повторений.

Синтаксис данных инструкций такой:

```php

switch ($_SERVER['REQUEST_URI']) {

    case '/':
        # code...
        require_once CONTROLLERS.'HomeController.php';
        break;

    case '/about':
        # code...
        require_once CONTROLLERS.'AboutController.php';;
        break;

```

Когда файл подключается, то его код оказывается в той же области видимости, что и строка в которой его подключили, таким образом все переменные, доступные в данной строке будут доступны и в подключаемом файле. 

Если вы подключаете файл внутри функции, то подключаемые файлы получают доступ к области видимости функции, таким образом следующий код тоже будет работать:

# Константы

Константы - это идентификаторы (имена) простых значений. Имена констант чувствительны к регистру. По принятому соглашению, имена констант всегда пишутся в верхнем регистре.

Имя константы должно соответствовать тем же правилам, что и другие имена в PHP. Правильное имя начинается с буквы или символа подчеркивания и состоит из букв, цифр и подчеркиваний. Регулярное выражение для проверки правильности имени константы выглядит так: 

```js

  [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*
```

## Правильные и неправильные имена констант
```php

    <?php

    // Правильные имена констант
    define("FOO",     "something");
    define("FOO2",    "something else");
    define("FOO_BAR", "something more");

    // Неправильные имена констант
    define("2FOO",    "something");

    // Это корректное объявление, но лучше его не использовать:
    // PHP однажды может зарегистрировать волшебную константу,
    // которая сломает ваш скрипт
    define("__FOO__", "something");

    ?>
```

Константы доступны из любой области видимости. Вы можете использовать константы в любом месте вашего скрипта, не обращая внимания на текущую область видимости. 

# Волшебные константы 

PHP предоставляет большой список предопределенных констант для каждого выполняемого скрипта. Многие из этих констант определяются различными модулями и будут присутствовать только в том случае, если эти модули доступны в результате динамической загрузки или в результате статической сборки.

Все волшебные константы разрешаются во время компиляции, в отличие от обычных констант, которые разрешаются во время исполнения. Специальные константы нечувствительны к регистру:

## Некоторые волшебные константы PHP

- __LINE__  Текущий номер строки в файле.

- __FILE__  Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.

- __DIR__ Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.

- __FUNCTION__  Имя функции.

- __CLASS__ Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). 

- __TRAIT__ Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).

- __METHOD__  Имя метода класса.

- __NAMESPACE__ Имя текущего пространства имен.



# Реализация минимального сайта

## Создаем файл настроек


## config/app.php

```php

<?php
  
  define('ROOT', realpath(__DIR__.'/../'));
  define('VIEWS', ROOT.'/views/');
  define('CONTROLLERS', ROOT.'/controllers/');
  define('CONFIG', ROOT.'/config/');
  define('CORE', ROOT.'/core/');
  define('APPNAME', 'Great Shopaholic');
  define('SLOGAN', 'Lets Build Cool Site');

```

## Создаем файл маршрутов Router.php

```php

  <?php

  switch ($_SERVER['REQUEST_URI']) {

      case '/':
          # code...
          require_once CONTROLLERS.'HomeController.php';
          break;

      case '/about':
          # code...
          require_once CONTROLLERS.'AboutController.php';;
          break;

      default:
          # code...
          echo "<h1>404</h1>";
  }

```

## Создаем файл контроллера HomeController.php

```php

  <?php

  require_once VIEWS.'home/index.php';

```

## Создаем файл представления home/index.php

```html

  <?php

  require_once VIEWS.'shared/head.php';
  require_once VIEWS.'shared/navigation.php';
  ?>
  <!-- product Start -->
  <section class="product">
      <div class="container">
          <div class="row">
              <div class="col-md-12">
                  <div class="feature_header text-center">
                      <h3 class="feature_title">Our <b>Cat Members</b></h3>
                      <h4 class="feature_sub">Lorem ipsum dolor sit amet, consectetur adipisicing elit. </h4>
                      <div class="divider"></div>
                  </div>
              </div>  <!-- Col-md-12 End -->
              <div class="product-items">


              </div>
          </div>
      </div> <!-- Conatiner product end -->
  </section>  <!-- Section product End -->

  <!-- Our product End -->
  <div class="clearfix"></div>

  <?php

  require_once VIEWS.'shared/footer.php';

  ?>

```

## Создаем файл загрузки приложения bootstrap/bootstrap.php

```php

<?php
require_once realpath(__DIR__).'/../config/app.php';
require_once CORE.'Router.php';

```
## Стартуем приложение index.php

```php

require_once realpath(__DIR__).'/../bootstrap/bootstrap.php';

```
